---
analyze_application_log_content:
  description: |-
    **LOG CONTENT ANALYSIS:**

    Analyze the provided log content: `{log_content}`

    **STEPS:**
    1. Use Application Log Analyzer to parse log content
    2. Extract incident details (timestamp, error type, class, method, line)
    3. Classify as NullPointerException or Configuration issue
    4. Set priority as P1/Critical
    5. Return structured JSON with extracted data

    **FOCUS:** Only extract real data from logs - no hallucination.
  expected_output: |-
    **STRUCTURED INCIDENT REPORT:**

    For **NullPointerException** incidents:
    ```json
    {
      "incident_type": "NullPointerException",
      "priority": "P1",
      "criticality": "Critical",
      "timestamp": "2025-09-15 21:58:30",
      "level": "ERROR",
      "thread": "http-nio-8889-exec-1",
      "logger": "dispatcherServlet",
      "endpoint": "/api/login",
      "message": "Request processing failed: java.lang.NullPointerException: Cannot invoke \"String.toString()\" because \"risky\" is null",
      "errorType": "NullPointerException",
      "exceptionClass": "java.lang.NullPointerException",
      "rootCauseMessage": "Cannot invoke \"String.toString()\" because \"risky\" is null",
      "className": "DemoController",
      "methodName": "login",
      "file": "DemoController.java",
      "line": 40,
      "stack": [
        "com.ai.mind.ops.DemoController.login(DemoController.java:40)",
        "java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
        "..."
      ],
      "suggested_fix_type": "code",
      "confidence": "high"
    }
    ```

    For **Configuration** incidents:
    ```json
    {
      "incident_type": "ConfigurationIssue",
      "priority": "P1",
      "criticality": "Critical",
      "timestamp": "2025-09-15 22:15:18",
      "level": "ERROR",
      "thread": "http-nio-8889-exec-3",
      "logger": "com.ai.mind.ops.DemoController",
      "error_code": "BILLING_403",
      "reason": "MissingConfig",
      "config_key": "BILLING_API_KEY",
      "amount": 120.0,
      "suggested_fix_type": "configuration",
      "confidence": "high"
    }
    ```

    **VALIDATION:**
    - Include parsing confidence level (high/medium/low)
    - Report any fields that couldn't be extracted
    - Provide clear incident classification reasoning
  agent: alert_detection_agent
orchestrate_incident_management_workflow:
  description: |-
    **INCIDENT ORCHESTRATION:**

    Receive incident data from detection agent and orchestrate workflow.

    **STEPS:**
    1. Generate incident ID: INC-[type]-P1-[timestamp]
    2. Store complete incident data in database using incident ID as key
    3. Output incident ID for resolution agent

    **TOOLS:** Use Current Date Tool, In-Memory Incident Database
  expected_output: "**ORCHESTRATION COMPLETION REPORT:**\n\n```json\n{\n  \"orchestration_status\":
    \"COMPLETED\",\n  \"incident_number\": \"INC-[incident_type]-[priority]-[timestamp]\",\n
    \ \"database_status\": \"STORED\",\n  \"incident_summary\": {\n    \"type\": \"[incident_type]\",\n
    \   \"priority\": \"[priority]\",\n    \"criticality\": \"[criticality_level]\",\n
    \   \"affected_component\": \"[component_name]\",\n    \"error_description\":
    \"[brief_description]\",\n    \"root_cause\": \"[specific_issue]\"\n  },\n  \"workflow_completion_time\":
    \"[current_timestamp]\"\n}\n```\n\n**CRITICAL OUTPUT FOR NEXT AGENT:**\n**INCIDENT_ID_FOR_RESOLUTION:
    INC-[incident_type]-[priority]-[timestamp]**\n\n**SUCCESS CRITERIA:**\n- ✅ Incident
    data properly structured and stored in database\n- ✅ Incident ID generated for
    workflow continuity\n- ✅ Complete technical details preserved for downstream
    tasks\n- ✅ Incident ID clearly provided for resolution workflow"
  agent: incident_orchestration_manager
  context:
  - analyze_application_log_content
complete_incident_resolution_workflow:
  description: |-
    **INCIDENT RESOLUTION:**

    Resolve incident using stored incident data.

    **STEPS:**
    1. Extract incident ID from orchestration output
    2. Retrieve incident data from database
    3. For NPE: Create GitHub PR using repository analyzer and PR creator
    4. For Config: Provide Confluence documentation
    5. Send Slack notification with resolution status
    6. Update incident status in database

    **REPOSITORY:** https://github.com/grrakesh/OpsMindJava (branch: main)
  expected_output: "**INCIDENT RESOLUTION COMPLETION REPORT:**\n\n```json\n{\n  \"resolution_status\":
    \"COMPLETED\",\n  \"incident_number\": \"[incident_id]\",\n  \"issue_type\": \"[code_fix|configuration]\",\n
    \ \"resolution_method\": \"[github_pr|confluence_documentation]\",\n  \"database_update\":
    \"SUCCESS\",\n  \"slack_notification\": {\n    \"channel\": \"all-opsmindai\",\n
    \   \"success\": true,\n    \"message_id\": \"[slack_message_timestamp]\"\n  },\n
    \ \"code_fix_details\": {\n    \"repository\": \"grrakesh/OpsMindJava\",\n    \"pr_url\":
    \"[github_pr_url]\",\n    \"branch\": \"fix/[incident_number]\",\n    \"files_changed\":
    \"[list_of_files]\",\n    \"root_cause\": \"[detailed_root_cause]\"\n  },\n  \"config_fix_details\":
    {\n    \"confluence_link\": \"https://equinixjira.atlassian.net/wiki/spaces/DIBS/pages/147016122410/Playbook+Migrating+of+ConfigMap+from+Stringified+JSON+XML+to+Native+format\",\n
    \   \"config_type\": \"[configuration_category]\", \n    \"manual_steps_required\":
    \"ConfigMap migration from stringified JSON/XML to native format\",\n    \"awaiting_manual_intervention\":
    true\n  },\n  \"incident_final_status\": \"[RESOLVED|DOCUMENTATION_PROVIDED]\",\n
    \ \"resolution_timestamp\": \"[current_timestamp]\"\n}\n```\n\n**SUCCESS CRITERIA:**\n-
    ✅ Incident data successfully retrieved from database\n- ✅ Issue type correctly
    identified and appropriate resolution applied  \n- ✅ For code issues: GitHub PR
    created with proper fix and documentation\n- ✅ For config issues: Official Equinix
    ConfigMap playbook provided with clear migration steps\n- ✅ Slack notification
    sent with resolution details and clear action items\n- ✅ Incident marked appropriately
    in database (Resolved or Documentation Provided)\n- ✅ For config issues: Clear
    guidance provided for ConfigMap migration and status updates\n- ✅ Complete transparency
    and communication maintained"
  agent: incident_fix_agent
  context:
  - orchestrate_incident_management_workflow
generate_comprehensive_incident_retrospective_report:
  description: >
    Generate a single professional PDF report for a specific incident_id,
    including detailed timeline and resolution analysis.

  CRITICAL_REQUIREMENTS:
    - Generate exactly one report for the provided incident_id
    - Use tools to extract full incident and timeline data
    - Include timeline and resolution analysis in the report

  EXECUTION_STEPS:
    - Extract incident_id from complete_incident_resolution_workflow

    - Call single_incident_reader with incident_id to get full incident data

    - Call timeline_extractor with incident_id:
        - Include structured timeline if available
        - If missing, note absence and impact

    - Create report content including:
        - Executive summary
        - Incident metadata (service_name, severity, status, commander, etc.)
        - Timeline breakdown (events, durations, milestones)
        - Resolution-focused analysis (if status is "Resolved"):
            - Root cause, fix, code changes, prevention strategies
            - Lessons learned and process improvements
            - If resolution_details missing, note limitation
        - Response team and playbook info
        - Actionable recommendations
    - Call pdf_generator ONCE with:
        incident_id: [incident_id]
        title: "Incident Retrospective Report for [incident_id]"
        content: [comprehensive analysis including timeline]
        output_filename: "COE_[incident_id].pdf"

    - Upload PDF to Slack:
        - Convert PDF to base64 using file_to_base64_converter
        - Upload via slack_file_uploader with:
            channel: 'all-opsmindai'
            file_content: [base64_content]
            filename: 'COE_[incident_id].pdf'
            title: 'Incident Retrospective Report - [incident_id]'
            initial_comment: >
              📋 *Incident Retrospective Report Generated*

              🆔 *Incident ID:* [incident_id]
              📊 *Report Type:* Comprehensive Root Cause Analysis
              📅 *Generated:* Today

              📝 This report includes:
              • Detailed incident analysis
              • Timeline reconstruction
              • Root cause identification
              • Actionable recommendations
              • Prevention strategies
            filetype: 'pdf'
            send_announcement: false
        - Confirm successful upload with file URL

  expected_output: |
    **INCIDENT RETROSPECTIVE REPORT (SUMMARY):**

    ```json
    {
      "incident_id": "INC-[type]-P1-[timestamp]",
      "report": {
        "pdf_path": "outputs/[incident_id]/COE_[incident_id].pdf",
        "generated": true
      },
      "slack_upload": {
        "success": true,
        "file_url": "https://files.slack.com/...",
        "channel": "C09DMPGG737"
      },
      "sections": [
        "Executive Summary",
        "Field-wise Breakdown",
        "Incident Timeline",
        "Root Cause Analysis",
        "Recommendations",
        "Conclusion"
      ]
    }
    ```

  agent: senior_incident_retrospective_analyst
  context:
  - complete_incident_resolution_workflow